"""
API for building formatting tree subnet built from fbx Subnet
"""

import hou
from . import classNodeNetwork as cnn
from . import fbxSubnet
from PIL import Image


def AssignMaterials(treeSubnet, matnetName, resetTransforms=True, matchSize=True, assignMat=True):
    """ Creates s@shop_materialpath attribute to existing primitive groups
    Returns formatted Tree Subnet """

    # Add nodes to geometry nodes
    for treeGeo in treeSubnet.children():
        # Define treeGeo network
        treeGeoNet = cnn.MyNetwork(treeGeo)

        # Bypass matnets, only run on geo
        if treeGeo.type().name() == "matnet" or treeGeo.type().name() == "shopnet":
            continue

        # Reset geo transformations
        if resetTransforms:
            treeGeo.parm("tx").revertToDefaults()
            treeGeo.parm("ty").revertToDefaults()
            treeGeo.parm("tz").revertToDefaults()

        # Clean old sops if any
        treeGeoNet.cleanNetwork("material", "pack", "output", method="type")
        treeGeoNet.cleanNetwork("assign_materials", method="name")
        #fileNode = treeGeoNet.findNodes("type", "file")[0]
        lastSop = treeGeoNet.findLastNode()

        # Add nodes
        addedNodes = ["pack", "output"]
        if matchSize:
            addedNodes.insert(0, "matchsize")
        if assignMat:
            addedNodes.insert(0, "attribwrangle")
        # Prefix of new nodes
        newNodesPrefix = treeSubnet.name() + "_"
        newNodes = treeGeoNet.addNodes(*addedNodes, prefix=newNodesPrefix)
        # Wire nodes
        treeGeoNet.wireNodes(newNodes, lastSop)

        # Set matchsize parms if exists
        if matchSize:
            matchsizeNode = treeGeoNet.findNodes("type", "matchsize")[0]
            matchsizeNode.setParms({"justify_y": 1})
            matchsizeNode.setParmExpressions({"offset_y": "bbox(0, D_YMIN)*ch('scale_to_match1/scale')"})
            matchsizeNode.setParms({"doscale": 1})
            matchsizeNode.setParms({"uniformscale": 1})
            matchsizeNode.setParms({"scale_axis": 0})

        # Add vex snippet to attribute wrangle. Create s@shop_materialpath to primitives
        if assignMat:
            assignWrangle = treeGeoNet.findNodes("type", "attribwrangle")[0]
            assignWrangle.setName(newNodesPrefix+"assign_materials")
            snippetParm = assignWrangle.parm("snippet")
            matnetPath = "../../{MATNETNAME}/".format(MATNETNAME=matnetName)
            assignSnippet = '''// Assign different materials for each primitive group
string groups[] = detailintrinsic(0, "primitivegroups");

foreach (string group; groups) {{
    if (inprimgroup(0,group,@primnum) == 1){{
        string path = "{MATNETPATH}" + re_replace("_group","",group) + "/";
        s@shop_materialpath = opfullpath(path);
        }}

    }}
            '''.format(MATNETPATH=matnetPath)
            snippetParm.set(assignSnippet)
            assignWrangle.setParms({"class": 1})

        # Layout children
        treeGeo.layoutChildren(vertical_spacing=0.35)
        # Set display flag
        treeGeoNet.findLastNode().setDisplayFlag(True)
        treeGeoNet.findLastNode().setRenderFlag(True)

    return treeSubnet

"""
def lodFormat(treeGeo):
    firstOutputLOD = treeGeo.outputs()[0]
    firstOutputLODNet = cnn.MyNetwork(firstOutputLOD)
    groupNodes = firstOutputLODNet.findNodes("group", method="type")
    if groupNodes:
        treeGeoNet = cnn.MyNetwork(treeGeo)
        lastNode = treeGeoNet.findLastNode()
        copiedGroupNodes = hou.copyNodesTo(tuple(groupNodes), treeGeo)
        treeGeoNet.wireNodes(copiedGroupNodes, lastNode)
        treeGeo.layoutChildren(vertical_spacing=0.35)
"""

def materialDirectory(treeSubnet):
    """
    :param treeSubnet: hou node object of the tree subnet
                       (generated by fbxSubnet.importSpeedTreeFbx)
    :return: Directory path of the .fbx file
    """
    # Query tree subnets
    treeSubnetNet = cnn.MyNetwork(treeSubnet)
    treeGeo = treeSubnetNet.findNodes("geo", method="type")

    treeGeoNet = cnn.MyNetwork(treeGeo[0])
    fileNode = treeGeoNet.findNodes("file", method="type")[0]

    # Get fbx file current directory
    fileNodeFilePath = fileNode.parm("file").eval()
    lastSlashIndex = fileNodeFilePath.rfind("/")
    fileNodeDirPath = fileNodeFilePath[0: lastSlashIndex]

    return fileNodeDirPath

def texturePathTemplate(matDir, materialName, extension, texType=""):
    """
    Returns texture path of texture. Assumes that material name has _MAT
    Example: Material Builder name: BostonFernLeaflets_Mat
             Texture will be path/to/dir/BostonFernLeaflets_Normal.png
    :param matDir: directory path of the texture files
    :param materialName: name of the material
    :param extension: extension of the texture file
    :param texType: normal, opacity, etc. Empty is diffuse
    :return: The full path of the texture
    """
    materialName = materialName.replace("_Mat", "")
    texType = "_" + texType if texType else ""
    return "{MATDIR}/{MATERIALNAME}{TEXTYPE}{EXTENSION}".format(MATDIR=matDir,
                                                       MATERIALNAME=materialName,
                                                       TEXTYPE=texType,
                                                       EXTENSION=extension)

def deleteMatnet(treeSubnet):
    """ Deletes matnet or shopnet in subnet """
    for child in treeSubnet.children():
        if child.type().name() == "matnet" or child.type().name() == "shopnet":
            child.destroy()
    return treeSubnet

def createMatnet(treeSubnet, matnetName):
    """
    Creates matnet with materials assigned to each of the groups
    :param treeSubnet: Tree Subnet with imported Speed tree fbx geo nodes
    :param matnetName: Name of the matnet for the tree subnet
    :return: tree subnet with matnet
    """
    # Delete old Matnet
    treeSubnet = deleteMatnet(treeSubnet)

    # Create Matnet
    treeMatnet = treeSubnet.createNode("matnet", matnetName)

    # Query first tree geo node in subnet. Groups in this treeGeo wil determine materials
    treeGeos = treeSubnet.children()
    allGroupMaterialNames = []
    for treeGeo in treeGeos:
        treeGeoNet = cnn.MyNetwork(treeGeo)

        # Create Redshift material networks based on existing primitive groups
        groupNodes = treeGeoNet.findNodes("group", method="type")
        groupNameParms = [groupNode.parm("crname") for groupNode in groupNodes]
        groupMaterials = [groupNameParm.eval().replace("_group", "") for groupNameParm in groupNameParms]
        allGroupMaterialNames.extend(groupMaterials)
    allGroupMaterialNames = set(allGroupMaterialNames)

    # Get path of the materials
    matDir = materialDirectory(treeSubnet)

    # Initialize Redshift Material Builders
    for materialName in allGroupMaterialNames:
        rsmb = treeMatnet.createNode("redshift_vopnet", materialName)
        rsmbOut = rsmb.children()[0]
        shader = rsmb.children()[1]

        # Texture extension
        texExt = ".png"
        
        # Create Diffuse
        colorVop = rsmb.createNode("redshift::TextureSampler", "Color")
        colorVop.setParms({"tex0_colorSpace": "sRGB"})
        colorPath = texturePathTemplate(matDir, materialName, texExt)
        colorVop.setParms({"tex0": colorPath})
        # Create Normal
        normalVop = rsmb.createNode("redshift::TextureSampler", "Normal")
        normalVop.setParms({"tex0_colorSpace": "Raw"})
        normalPath = texturePathTemplate(matDir, materialName, texExt, texType="Normal")
        normalVop.setParms({"tex0": normalPath})
        # Create Bump Vop
        bumpVop = rsmb.createNode("redshift::BumpMap")
        bumpVop.setParms({"inputType": "Tangent-Space Normal"})
        # Shader Parms
        shader.setParms({"refl_weight": 0.01})
        shader.setParms({"refl_brdf": "GGX"})
        # Connect Diffuse
        shader.setInput(0, colorVop, 0)
        if "leaf" in materialName.lower() or "leaves" in materialName.lower():
            shader.setInput(3, colorVop, 0)  # Translucency
            shader.setParms({"transl_weight": 0.25})
        # Connect Bump Vop
        shader.setInput(52, bumpVop, 0)
        # Connect Normal
        bumpVop.setInput(0, normalVop, 0)

        # Find Opacity Image
        try:
            texOpacityPath = texturePathTemplate(matDir, materialName, texExt, texType="Opacity")
            # Sample Opacity Image
            img = Image.open(texOpacityPath)
            imgData = list(img.getdata(band=0))
            hasAlpha = 0 in imgData  # True if image has 0 in opacity texture
            img.close()
        except FileNotFoundError:
            hasAlpha = None
        # Create Sprite Vop if Opacity tex has 0 (default opacity is full white)
        if hasAlpha:
            # Create Sprite Vop if Opacity image has data
            spriteVop = rsmb.createNode("redshift::Sprite")
            spriteVop.setParms({"tex0_colorSpace": "Raw"})
            spritePath = texOpacityPath
            spriteVop.setParms({"tex0": spritePath})
            # Connect Sprite Vop
            rsmbOut.setInput(0, spriteVop, 0)
            spriteVop.setInput(0, shader, 0)
        # Layout texture and shader nodes
        rsmb.layoutChildren()

    # Format tree matnet
    treeMatnet.layoutChildren(vertical_spacing=1)

    return treeSubnet

